<!DOCTYPE html>
<html lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Documentation | ESBMC</title>
<meta name="generator" content="Jekyll v3.7.3">
<meta property="og:title" content="ESBMC: An Industrial-Strength C Model Checker">
<meta property="og:locale" content="en_US">
<meta name="description" content="SMT-based Context-Bounded Model Checker for C Programs.">
<meta property="og:description" content="SMT-based Context-Bounded Model Checker for C Programs.">
<link rel="canonical" href="https://ssvlab.github.io/">
<meta property="og:url" content="https://ssvlab.github.io/">
<meta property="og:site_name" content="ESBMC">
<script type="application/ld+json">
{"name":"ESBMC","description":"SMT-based Context-Bounded Model Checker for C Programs..","@type":"WebSite","url":"https://ssvlab.github.io/","headline":"News","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="./files/style.css">
    <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="https://ssvlab.github.io/esbmc/index.html">ESBMC</a></h1>
        <p>An Efficient SMT-based Bounded Model Checker.</p>
        <p class="view"><a class="hl" href="https://github.com/ssvlab/esbmc"><b>GitHub</b></a></p>
        <p class="view">
          <a href="https://ssvlab.github.io/esbmc/documentation.html"><b>Documentation</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/news.html"><b>News</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/publications.html"><b>Publications</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/sv-comp.html"><b>SV-COMP</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/test-comp.html"><b>Test-Comp</b></a><br>
	  <a href="https://ssvlab.github.io/esbmc/people.html"><b>People</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/applications.html"><b>Applications</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/archive.html"><b>Download Archive</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/contrib.html"><b>Third Party Contributions</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/benchmarks/"><b>Index of /benchmarks</b></a><br>	

        </p>
      </header>
      <section>

      <h2 id="documentation">Documentation</h2>

          <p>First things first, download the lastest version of ESBMC for Linux OS <a href="https://github.com/esbmc/esbmc/releases/download/v6.0/esbmc-v6.0.0-linux-static-64.tgz"><b>here</b></a>. ESBMC is hosted on <a href="https://github.com/esbmc/esbmc" target="_blank">GitHub</a>.</p>

	  <a href="#how-to-install">Installing ESBMC</a>
	  <br>
          <a href="#show-features">ESBMC Features</a>
	  <br>
          <a href="#unwinding-assertions">Unwinding Assertions</a>
          <br>
	  <a href="#modelling-nondeterminism">Modeling with non-determinism</a>
	  <br>
	  <a href="#how-to-run">Illustrative Examples</a>
	  <br>
	  <a href="#esbmc-support">ESBMC Support</a>
	  <br>
          <br>

          <p>A demonstration is available <a href="https://www.youtube.com/watch?v=YcJjXHlN1v8" target="_blank">here</a>.</p>

          <h3 id="how-to-install">Installing ESBMC</h3>

	  <p>As a prerequisite, we recommend to install ESBMC on a GNU/Linux operating system. In order to install ESBMC on your machine, you should download the <a href="https://github.com/esbmc/esbmc/releases/download/v6.0/esbmc-v6.0.0-linux-static-64.tgz"><b>tool archive</a></b> and save it on your disk. After that, you should open the terminal prompt and decompress the archive using the following command:</p>

          <pre style="color: silver; background: black;">$tar xfz esbmc.tgz</pre>


          <p>The ESBMC distribution is split into five directories:</p>

          <ul>
              <li><code>bin</code>: contains a static-binary file of ESBMC;</li>
              <li><code>include</code>: contains the headers for the C++ API;</li>
              <li><code>lib</code>: contains the libesbmc.a, which can be statically linked to a C++ or imported into a python script;</li>
              <li><code>license</code>: contains the ESBMC, Z3 and Boolector licenses;</li>
              <li><code>share</code>: contains our simplified model of the STL library.</li>
          </ul>

          <h3 id="show-features">ESBMC Features</h3>

          <p>ESBMC aims to support all of C99, and detects errors in software by simulating a finite prefix of the program execution with all possible inputs. Classes of problems that can be detected include:</p>

          <ul>
              <li>User specified assertion failures;</li>
              <li>Out of bounds array access;</li>
              <li>Illegal pointer dereferences, such as:</li>
              <ul>
                <li>Dereferencing null;</li>
                <li>Performing an out-of-bounds dereference;</li>
                <li>Double-free of malloc'd memory;</li>
                <li>Misaligned memory access;</li>
              </ul>
              <li>Integer overflows;</li>
              <li>NaN (Floating-point);</li>
              <li>Divide by zero;</li>
              <li>Memory leak.</li>
          </ul>

          <p>Concurrent software (using the pthread API) is verified by explicit exploration of interleavings, thus producing one symbolic execution per interleaving. By default, only normal errors will be checked for; one can also specify options to check concurrent programs for:</p>

          <ul>
            <li>Deadlock (only on pthread mutexes and conditional variables);</li>
            <li>Data races (<i>i.e.</i>, competing writes);</li>
          </ul>

          <p>By default ESBMC performs a ''lazy'' depth first search of interleavings, but can also encode (explicitly) all interleavings into a single SMT formula. Currently, a number of SMT solvers are supported:</p>

          <ul>
            <li>Z3 4.0+;</li>
            <li>Boolector 3.0+;</li>
            <li>MathSAT;</li>
            <li>CVC4;</li>
            <li>Yices 2.2+;</li>
          </ul>

          <p>In addition, ESBMC can be configured to use the SMTLIB interactive text format with a pipe, to communicate with an arbitrary solver process, although not-insignificant overheads are involved. A limited subset of C++98 is supported too -- a library modeling the STL is also available.</p>

          <p>To check all available options of the ESBMC tool, type:</p>

          <pre style="color: silver; background: black;">$esbmc --help</pre>


          <h3 id="unwinding-assertions">Unwinding Assertions</h3>

          <p>In ESBMC, all loops are "unwound", i.e., replaced by several guarded copies of the loop body; the same happens for backward "gotos" and recursive functions. Soundness requires that ESBMC insert a so-called <i>unwinding assertion</i> at the end of the loop. As an example, consider the simple C code fragment illustrated below:</p>
	  
<body>
<pre class='brush: c'>
1 unsigned int x=∗;
2 while ( x>0) x−−;
3 assert ( x==0);
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>
</body>
	  
<p> Note that the loop in line 2 runs an unknown number of times, depending on the initial non-deterministic value assigned to x in line 1. The assertion in line 3 holds independent of x's initial value. BMC tools typically fail to verify programs that contain such loops. In particular, BMC tools introduce an unwinding assertion at the end of the loop, as illustrated in line 5 of this C code fragment. 

<body>  
<pre class='brush: c'>
1 unsigned int x=∗;
2 if(x>0)
3   x−−;   // k copies
4   ...
5 assert (!(x>0));
6 assert(x==0);
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>
</body>

<p>This unwinding assertion in line 5 causes the BMC tool to fail if <i>k</i> is too small.</p>

          <h3 id="modelling-nondeterminism">Modeling with non-determinism</h3>

	  <p>ESBMC extends C with three modeling features:</p>


	  <h3 id="how-to-run">Illustrative Examples</h3>

          <p>As an illustrative example to show some of the ESBMC features concerning floating-point numbers, consider the following C code:  </p>

	  <head>
            <link href="css/shCore.css" rel="stylesheet" type="text/css" />
            <link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />
          </head>

          <body>
          <pre class='brush: c'>
#include &lt;math.h&gt;
int main() {
  unsigned int N = nondet_uint();
  double x = nondet_double();
  if(x <= 0 || isnan(x))
    return 0;
  unsigned int i = 0;
  while(i < N) {
    x = (2*x);
    assert(x>0);
    ++i;
  }
  assert(x>0);
  return 0;
}
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>
</body>

          <p>Here, ESBMC is invoked as follows: </p>

          <pre style="color: silver; background: black;">$esbmc file.c --floatbv --k-induction</pre>

	  <p> where <i>file.c</i> is the C program to be checked, <i>--floatbv</i> indicates that ESBMC will use floating-point arithmetic to represent the program's <i>float</i> and <i>double</i> variables, and <i>--k-induction</i> selects the <i>k</i>-induction proof rule. The user can select the SMT solver, property, and verification strategy. For this particular C program, ESBMC provides the following output as the verification result:</p>

<pre style="color: silver; background: black;">
*** Checking inductive step
Starting Bounded Model Checking
Unwinding loop 2 iteration 1 file ex5.c line 8 function main
Not unwinding loop 2 iteration 2 file ex5.c line 8 function main
Symex completed in: 0.001s (40 assignments)
Slicing time: 0.000s (removed 16 assignments)
Generated 2 VCC(s), 2 remaining after simplification (24 assignments)
No solver specified; defaulting to Boolector
Encoding remaining VCC(s) using bit-vector/floating-point arithmetic
Encoding to solver time: 0.005s
Solving with solver Boolector 3.2.0
Encoding to solver time: 0.005s
Runtime decision procedure: 0.427s
BMC program time: 0.435s

VERIFICATION SUCCESSFUL
</pre>
Solution found by the inductive step (k = 2)


<p>As antoher illustrative example to show some of the ESBMC features concerning pointer safety, consider the following C code:  </p>

	  <head>
            <link href="css/shCore.css" rel="stylesheet" type="text/css" />
            <link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />
          </head>

          <body>
          <pre class='brush: c'>
#include &lt;stdlib.h&gt;
int *a, *b;
int n;
#define BLOCK_SIZE 128
void foo () {
  int i;
  for (i = 0; i < n; i++)
    a[i] = -1;
  for (i = 0; i < BLOCK_SIZE - 1; i++)
    b[i] = -1;
}
int main () {
  n = BLOCK_SIZE;
  a = malloc (n * sizeof(*a));
  b = malloc (n * sizeof(*b));
  *b++ = 0;
  foo ();
  if (b[-1])
  { free(a); free(b); }
  else
  { free(a); free(b); }
  return 0;
}
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>
</body>

          <p>Here, ESBMC is invoked as follows: </p>

          <pre style="color: silver; background: black;">$esbmc file.c --memory-leak-check</pre>

	  <p> where <i>file.c</i> is the C program to be checked and <i>--memory-leak-check</i> indicates that ESBMC will check for memory leaks. For this particular C program, ESBMC produces the following counterexample:</p>

<pre style="color: silver; background: black;">
Counterexample:

State 1 file ex2.c line 14 function main thread 0
----------------------------------------------------
  a = (signed int *)(&dynamic_1_array[0])

State 2 file ex2.c line 15 function main thread 0
----------------------------------------------------
  b = (signed int *)0

State 3 file ex2.c line 16 function main thread 0
----------------------------------------------------
  b = 0 + 1

State 6 file ex2.c line 16 function main thread 0
----------------------------------------------------
Violated property:
  file ex2.c line 16 function main
  dereference failure: NULL pointer
</pre>

          <p>In the counterexample shown above, State 1 indicates that memory has been allocated, which is identified by 'dynamic_1_array'. State 2 indicates that the call to the malloc function did not succeed, and thus returned NULL, i.e., the memory was not allocated. State 3 represents an assignment to pointer b. Lastly, State 6 reports a failure to dereference pointer b.</p>

	  <h3 id="esbmc-support">ESBMC Support</h3>
	  
          <p>We are still increasing the robustness of ESBMC and also continuously implementing new features, more optimizations and experiencing new encodings. For any question about ESBMC, please contact <code>esbmc@googlegroups.com</code>.</p>

        </section>
      <footer>

        <p><small>© 2018 Systems & Software Verification Laboratory</small></p>
      </footer>
    </div>
    <script src="./files/scale.fix.js.download"></script>



</body></html>
