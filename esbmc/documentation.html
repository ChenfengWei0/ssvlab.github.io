<!DOCTYPE html>
<html lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>

<!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Documentation | ESBMC</title>
<meta name="generator" content="Jekyll v3.7.3">
<meta property="og:title" content="ESBMC: An Industrial-Strength C Model Checker">
<meta property="og:locale" content="en_US">
<meta name="description" content="SMT-based Context-Bounded Model Checker for C Programs.">
<meta property="og:description" content="SMT-based Context-Bounded Model Checker for C Programs.">
<link rel="canonical" href="https://ssvlab.github.io/">
<meta property="og:url" content="https://ssvlab.github.io/">
<meta property="og:site_name" content="ESBMC">
<script type="application/ld+json">
{"name":"ESBMC","description":"SMT-based Context-Bounded Model Checker for C Programs..","@type":"WebSite","url":"https://ssvlab.github.io/","headline":"News","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="./files/style.css">
    <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="https://ssvlab.github.io/esbmc/index.html">ESBMC</a></h1>
        <p>An Efficient SMT-based Bounded Model Checker.</p>
        <p class="view"><a class="hl" href="https://github.com/ssvlab/esbmc" target="_blank"><b>GitHub</b></a></p>
        <p class="view">
          <a href="https://ssvlab.github.io/esbmc/documentation.html"><b>Documentation</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/news.html"><b>News</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/publications.html"><b>Publications</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/sv-comp.html"><b>SV-COMP</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/test-comp.html"><b>Test-Comp</b></a><br>
	  <a href="https://ssvlab.github.io/esbmc/people.html"><b>People</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/applications.html"><b>Applications</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/archive.html"><b>Download Archive</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/contrib.html"><b>Third Party Contributions</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/benchmarks/"><b>Index of /benchmarks</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/acknowledgements.html"><b>Acknowledgements</b></a><br>
        </p>
      </header>
      <section>

      <h2 id="documentation">Documentation</h2>

      <!--  <p>First things first, download the lastest version of ESBMC for Linux OS <a href="https://github.com/esbmc/esbmc/releases/download/v6.0/esbmc-v6.0.0-linux-static-64.tgz"><b>here</b></a>. ESBMC is hosted on <a href="https://github.com/esbmc/esbmc" target="_blank">GitHub</a>.</p> -->

	  <a href="#how-to-install">Installing ESBMC</a>
	  <br>
      <a href="#show-features">ESBMC Features</a>
	  <br>
	  <a href="#how-to-run">Illustrative Examples</a>
	  <br>
      <a href="#witness">Witness Generation</a>
	  <br>
      <a href="#unwinding-assertions">Unwinding Assertions</a>
      <br>
      <a href="#modelling-nondeterminism">Modeling with non-determinism</a>
      <br>
      <a href="#falsification">Falsification</a>
      <br>
      <a href="#incremental-bmc">Incremental BMC</a>
      <br>
      <a href="#k-induction">k-Induction proof rule</a>
      <br>
      <a href="#multiple-files">Verification of modules that rely on larger structures</a>
      <br>
      <a href="#esbmc-solidity">Verification of Solidity Smart Contracts</a>
      <br>
	  <a href="#esbmc-support">ESBMC Support</a>
	  <br>
          <br>

          <p>A demonstration is available <a href="https://www.youtube.com/watch?v=YcJjXHlN1v8" target="_blank">here</a>.</p>

          <p>You can also use ESBMC via our <a href="http://18.225.0.33/esbmc.php"> web interface</a>.

	      <p>A set of slides about the detection of software vulnerabilities using ESBMC: <a href="https://ssvlab.github.io/lucasccordeiro/courses/2020/01/software-security/slides/lecture03.pdf"> Part I</a>, <a href="https://ssvlab.github.io/lucasccordeiro/courses/2020/01/software-security/slides/lecture04.pdf"> Part II</a>, and <a href="https://ssvlab.github.io/lucasccordeiro/courses/2020/01/software-security/slides/lecture05.pdf"> Part III</a>.

          <p>This <a href="https://ssvlab.github.io/lucasccordeiro/courses/2020/01/software-security/index.html">software security</a> course describes further implementation details about ESBMC.</p>
          <h3 id="how-to-install">Installing ESBMC</h3>

	  <p>As a prerequisite, we recommend installing ESBMC on a GNU/Linux OS (the support for MacOS is still experimental). In order to install ESBMC on your machine, you should download the <a href="https://github.com/esbmc/esbmc/releases/latest/download/ESBMC-Linux.sh">ESBMC-Linux.sh</a> (or <a href="https://github.com/esbmc/esbmc/releases/latest/download/ESBMC-Darwin.sh">ESBMC-Darwin.sh</a>) and save it on your disk. After that, you should open the terminal prompt and run the shell script using the following commands.</p>

	  <p>For Linux:</p>
          <pre style="color: silver; background: black;">$chmod +x ESBMC-Linux.sh</pre>
          <pre style="color: silver; background: black;">$./ESBMC-Linux.sh</pre>

	  <p>For MacOS (experimental):</p>
          <pre style="color: silver; background: black;">$chmod +x ESBMC-Darwin.sh</pre>
          <pre style="color: silver; background: black;">$./ESBMC-Darwin.sh</pre>

          <p>Once the user runs the above shell-script, he/she should read the license before proceeding with the installation. The ESBMC distribution is split into two directories:</p>

          <ul>
              <li><code>bin</code>: contains a static-binary file of ESBMC;</li>
              <li><code>license</code>: contains the ESBMC, Z3 and Boolector licenses.</li>
          </ul>

	  <p>If the user wants to use other SMT solvers (e.g., MathSAT, Yices, CVC4), we recommend checking out the ESBMC source code, which is hosted on <a href="https://github.com/esbmc/esbmc" target="_blank">GitHub</a>, and then follow the instructions in the <a href="https://github.com/esbmc/esbmc/blob/master/BUILDING.md" target="_blank">BUILDING </a>file.</p>

          <h3 id="show-features">ESBMC Features</h3>

          <p>ESBMC aims to support all of C11, and detects errors in software by simulating a finite prefix of the program execution with all possible inputs. Classes of problems that can be detected include:</p>

          <ul>
              <li>User specified assertion failures;</li>
              <li>Out of bounds array access;</li>
              <li>Illegal pointer dereferences, such as:</li>
              <ul>
                <li>Dereferencing null;</li>
                <li>Performing an out-of-bounds dereference;</li>
                <li>Double-free of malloc'd memory;</li>
                <li>Misaligned memory access;</li>
              </ul>
              <li>Integer overflows;</li>
              <li>NaN (Floating-point);</li>
              <li>Divide by zero;</li>
              <li>Memory leak.</li>
          </ul>

          <p>Concurrent software (using the pthread API) is verified by explicit exploration of interleavings, thus producing one symbolic execution per interleaving. By default, only normal errors will be checked for; one can also specify options to check concurrent programs for:</p>

          <ul>
            <li>Deadlock (only on pthread mutexes and conditional variables);</li>
            <li>Data races (<i>i.e.</i>, competing writes);</li>
          </ul>

          <p>By default ESBMC performs a ''lazy'' depth first search of interleavings, but can also encode (explicitly) all interleavings into a single SMT formula. Currently, a number of SMT solvers are supported:</p>

          <ul>
            <li>Z3 4.8+;</li>
            <li>Boolector 3.2+;</li>
            <li>MathSAT 5.6+;</li>
            <li>CVC4;</li>
            <li>Yices 2.6+;</li>
          </ul>

          <p>In addition, ESBMC can be configured to use the SMTLIB interactive text format with a pipe, to communicate with an arbitrary solver process, although not-insignificant overheads are involved. A limited subset of C++98 is supported too -- a library modeling the STL is also available.</p>

	  <p>ESBMC uses clang as its front-end, which brings a number of advantages:</p>

          <ul>
            <li>We address the problem of maintaining a frontend for C and C++ simply and elegantly: by using clangs API to access and traverse the program AST, without having details of the input program compiled away.</li>
	    <li>ESBMC provides compilation error messages as expected from a compiler.</li>
	    <li>ESBMC leverages clangâ€™s powerful static analyzer to provide meaningful warnings when parsing the program.</li>
	    <li>Clang can simplify some expressions, e.g., calculate <i>sizeof/alignof</i> expressions, evaluate static asserts, evaluate if a dynamic cast is always null, etc., which eases the analysis of the input program.</li>
          </ul>

          <p>To check all available options of the ESBMC tool, type:</p>

          <pre style="color: silver; background: black;">$esbmc --help</pre>

	  	  <h3 id="how-to-run">Illustrative Examples</h3>

          <p>As an illustrative example to show some of the ESBMC features concerning floating-point numbers, consider the following C code:  </p>

<head>
<link href="css/shCore.css" rel="stylesheet" type="text/css" />
<link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />
</head>
<body>
<pre class='brush: c'>
#include &lt;math.h&gt;
int main() {
  unsigned int N = nondet_uint();
  double x = nondet_double();
  if(x <= 0 || isnan(x))
    return 0;
  unsigned int i = 0;
  while(i < N) {
    x = (2*x);
    assert(x>0);
    ++i;
  }
  assert(x>0);
  return 0;
}
</pre>
<script src="js/shCore.js"></script>
<script src="js/shBrushCpp.js"></script>
<script>
SyntaxHighlighter.all()
</script>
</body>

          <p>Here, ESBMC is invoked as follows: </p>

          <pre style="color: silver; background: black;">$esbmc file.c --floatbv --k-induction</pre>

	  <p> where <i>file.c</i> is the C program to be checked, <i>--floatbv</i> indicates that ESBMC will use floating-point arithmetic to represent the program's <i>float</i> and <i>double</i> variables, and <i>--k-induction</i> selects the <i>k</i>-induction proof rule. The user can select the SMT solver, property, and verification strategy. For this particular C program, ESBMC provides the following output as the verification result:</p>

<pre style="color: silver; background: black;">
*** Checking inductive step
Starting Bounded Model Checking
Unwinding loop 2 iteration 1 file ex5.c line 8 function main
Not unwinding loop 2 iteration 2 file ex5.c line 8 function main
Symex completed in: 0.001s (40 assignments)
Slicing time: 0.000s (removed 16 assignments)
Generated 2 VCC(s), 2 remaining after simplification (24 assignments)
No solver specified; defaulting to Boolector
Encoding remaining VCC(s) using bit-vector/floating-point arithmetic
Encoding to solver time: 0.005s
Solving with solver Boolector 3.2.0
Encoding to solver time: 0.005s
Runtime decision procedure: 0.427s
BMC program time: 0.435s

VERIFICATION SUCCESSFUL

Solution found by the inductive step (k = 2)
</pre>

<p>As an illustrative example to show some of the ESBMC features concerning pointer safety, consider the following C code:  </p>

	  <head>
            <link href="css/shCore.css" rel="stylesheet" type="text/css" />
            <link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />
          </head>

          <body>
          <pre class='brush: c'>
#include &lt;stdlib.h&gt;
int *a, *b;
int n;
#define BLOCK_SIZE 128
void foo () {
  int i;
  for (i = 0; i < n; i++)
    a[i] = -1;
  for (i = 0; i < BLOCK_SIZE - 1; i++)
    b[i] = -1;
}
int main () {
  n = BLOCK_SIZE;
  a = malloc (n * sizeof(*a));
  b = malloc (n * sizeof(*b));
  *b++ = 0;
  foo ();
  if (b[-1])
  { free(a); free(b); }
  else
  { free(a); free(b); }
  return 0;
}
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>
</body>

          <p>Here, ESBMC is invoked as follows: </p>

          <pre style="color: silver; background: black;">$esbmc file.c --memory-leak-check</pre>

	  <p> where <i>file.c</i> is the C program to be checked and <i>--memory-leak-check</i> indicates that ESBMC will check for memory leaks. For this particular C program, ESBMC produces the following counterexample:</p>

<pre style="color: silver; background: black;">
Counterexample:

State 1 file ex2.c line 14 function main thread 0
----------------------------------------------------
  a = (signed int *)(&dynamic_1_array[0])

State 2 file ex2.c line 15 function main thread 0
----------------------------------------------------
  b = (signed int *)0

State 3 file ex2.c line 16 function main thread 0
----------------------------------------------------
  b = 0 + 1

State 6 file ex2.c line 16 function main thread 0
----------------------------------------------------
Violated property:
  file ex2.c line 16 function main
  dereference failure: NULL pointer
</pre>

<p>In the counterexample shown above, State 1 indicates that memory has been allocated, which is identified by 'dynamic_1_array'. State 2 indicates that the call to the <i>malloc</i> function did not succeed, and thus returned NULL, i.e., the memory was not allocated. Note that ESBMC allows the user not to check for malloc/new failure via <i>--force-malloc-success</i>. State 3 represents an assignment to pointer b. Lastly, State 6 reports a failure to dereference pointer b.</p>

          <p>As an illustrative example to show some of the ESBMC features concerning concurrency, consider the following C code:  </p>
<head>
<link href="css/shCore.css" rel="stylesheet" type="text/css" />
<link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />
</head>
<body>
<pre class='brush: c'>
#include &lt;pthread.h&gt;
int n=0; //shared variable
pthread_mutex_t mutex;
void* P(void* arg) {
  int tmp, i=1;
  while (i<=10) {
    pthread_mutex_lock(&mutex);
    tmp = n;
    n = tmp + 1;
    pthread_mutex_unlock(&mutex);
    i++;
  }
  return NULL;
}
int main (void) {
  pthread_t id1, id2;
  pthread_mutex_init(&mutex, NULL);
  pthread_create(&id1, NULL, P, NULL);
  pthread_create(&id2, NULL, P, NULL);
  pthread_join(id1, NULL);
  pthread_join(id2, NULL);
  assert(n == 20);
}
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>
  </body>

  <p>Here, we create two threads <i>id1</i> and <i>id1</i>; both threads will run the same code as implemented in <b>P</b>. Note that these two threads communicate via the shared memory <i>n</i>, which is protected by a mutex via <b>pthread_mutex_lock</b> and <b>pthread_mutex_unlock</b>. Note further that the thread <i>main</i> contains two joining points via <b>pthread_join</b> for <i>id1</i> and <i>id2</i>.</p>

            <p>ESBMC can be invoked as follows: </p>

          <pre style="color: silver; background: black;">$esbmc file.c --context-bound 2</pre>

          <p> where <i>file.c</i> is the C program to be checked and <i>--context-bound nr</i> limits number of context switches for each thread. For this particular C program, ESBMC produces the following verification result:</p>

<pre style="color: silver; background: black;">
*** Thread interleavings 612 ***
Unwinding loop 1 iteration 10 file test3.c line 6 function P
Unwinding loop 1 iteration 1 file test3.c line 6 function P
Unwinding loop 1 iteration 2 file test3.c line 6 function P
Unwinding loop 1 iteration 3 file test3.c line 6 function P
Unwinding loop 1 iteration 4 file test3.c line 6 function P
Unwinding loop 1 iteration 5 file test3.c line 6 function P
Unwinding loop 1 iteration 6 file test3.c line 6 function P
Unwinding loop 1 iteration 7 file test3.c line 6 function P
Unwinding loop 1 iteration 8 file test3.c line 6 function P
Unwinding loop 1 iteration 9 file test3.c line 6 function P
Unwinding loop 1 iteration 10 file test3.c line 6 function P
Symex completed in: 0.031s (431 assignments)
Slicing time: 0.001s (removed 183 assignments)
Generated 149 VCC(s), 7 remaining after simplification (248 assignments)
No solver specified; defaulting to Boolector
Encoding remaining VCC(s) using bit-vector/floating-point arithmetic
Encoding to solver time: 0.004s
Solving with solver Boolector 3.2.0
Encoding to solver time: 0.004s
Runtime decision procedure: 0.001s
BMC program time: 0.040s

VERIFICATION SUCCESSFUL
</pre>

          <h3 id="witness">Witness Generation</h3>

          <p>When ESBMC refutes a property, it produces a counterexample that can be used to debug the program to find the root cause of the problem. For this purpose, ESBMC can produce the counterexample in graphml format to make its evaluation easier (e.g., by building a tool that allows graphical visualization). </p>

          <p>As an illustrative example, consider the following fragment of C code, where we declare two bit-vectors of size 10 each: x and y, and then check whether x == y. </p>

          <head>
<link href="css/shCore.css" rel="stylesheet" type="text/css" />
<link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />
</head>
<body>
<pre class='brush: c'>
#include &lt;assert.h&gt;

int main() {
  _ExtInt(10) x = nondet_float();
  _ExtInt(10) y = nondet_int();
  assert(x == y);
  return 0;
}
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>
  </body>

          <p>If we call ESBMC as <i>esbmc main.c --witness-output main.graphml</i>, where <i>main.c</i> is the C program we want to verify while <i>main.graphml</i> stores the counterexample in graphml format, then ESBMC will produce the following output:</p>

<pre style="color: silver; background: black;">
<xmp>
<?xml version="1.0" encoding="utf-8"?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <key id="frontier" attr.name="isFrontierNode" attr.type="boolean" for="node">
    <default>false</default>
  </key>
  <key id="violation" attr.name="isViolationNode" attr.type="boolean" for="node">
    <default>false</default>
  </key>
  <key id="entry" attr.name="isEntryNode" attr.type="boolean" for="node">
    <default>false</default>
  </key>
  <key id="sink" attr.name="isSinkNode" attr.type="boolean" for="node">
    <default>false</default>
  </key>
  <key id="cyclehead" attr.name="cyclehead" attr.type="boolean" for="node">
    <default>false</default>
  </key>
  <key id="sourcecodelang" attr.name="sourcecodeLanguage" attr.type="string" for="graph"/>
  <key id="programfile" attr.name="programfile" attr.type="string" for="graph"/>
  <key id="programhash" attr.name="programhash" attr.type="string" for="graph"/>
  <key id="creationtime" attr.name="creationtime" attr.type="string" for="graph"/>
  <key id="specification" attr.name="specification" attr.type="string" for="graph"/>
  <key id="architecture" attr.name="architecture" attr.type="string" for="graph"/>
  <key id="producer" attr.name="producer" attr.type="string" for="graph"/>
  <key id="sourcecode" attr.name="sourcecode" attr.type="string" for="edge"/>
  <key id="startline" attr.name="startline" attr.type="int" for="edge"/>
  <key id="startoffset" attr.name="startoffset" attr.type="int" for="edge"/>
  <key id="control" attr.name="control" attr.type="string" for="edge"/>
  <key id="invariant" attr.name="invariant" attr.type="string" for="node"/>
  <key id="invariant.scope" attr.name="invariant.scope" attr.type="string" for="node"/>
  <key id="assumption" attr.name="assumption" attr.type="string" for="edge"/>
  <key id="assumption.scope" attr.name="assumption" attr.type="string" for="edge"/>
  <key id="assumption.resultfunction" attr.name="assumption.resultfunction" attr.type="string" for="edge"/>
  <key id="enterFunction" attr.name="enterFunction" attr.type="string" for="edge"/>
  <key id="returnFromFunction" attr.name="returnFromFunction" attr.type="string" for="edge"/>
  <key id="endline" attr.name="endline" attr.type="int" for="edge"/>
  <key id="endoffset" attr.name="endoffset" attr.type="int" for="edge"/>
  <key id="threadId" attr.name="threadId" attr.type="string" for="edge"/>
  <key id="createThread" attr.name="createThread" attr.type="string" for="edge"/>
  <key id="witness-type" attr.name="witness-type" attr.type="string" for="graph"/>
  <graph edgedefault="directed">
    <data key="producer">ESBMC 6.7.0</data>
    <data key="sourcecodelang">C</data>
    <data key="architecture">64bit</data>
    <data key="programfile">main.c</data>
    <data key="programhash">7ba149c407ef7ae9e971bbc937b37a624575d6a5</data>
    <data key="specification">CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )</data>
    <data key="creationtime">2021-06-07T13:37:38</data>
    <data key="witness-type">violation_witness</data>
    <node id="N0">
      <data key="entry">true</data>
    </node>
    <node id="N1"/>
    <edge id="E0" source="N0" target="N1">
      <data key="enterFunction">main</data>
      <data key="createThread">0</data>
    </edge>
    <node id="N2"/>
    <edge id="E1" source="N1" target="N2">
      <data key="startline">4</data>
      <data key="assumption">x = -512;</data>
      <data key="threadId">0</data>
    </edge>
    <node id="N3"/>
    <edge id="E2" source="N2" target="N3">
      <data key="startline">5</data>
      <data key="assumption">y = -166;</data>
      <data key="threadId">0</data>
    </edge>
    <node id="N4">
      <data key="violation">true</data>
    </node>
    <edge id="E3" source="N3" target="N4">
      <data key="startline">93</data>
      <data key="threadId">0</data>
    </edge>
  </graph>
</graphml>
</xmp>

</pre>
         <p>We recommend reading <a href="https://github.com/sosy-lab/sv-witnesses">Exchange Format for Violation Witnesses and Correctness Witnesses</a> to obtain further information about violation and correctness witnesses in graphml format.</p>


          <h3 id="unwinding-assertions">Unwinding Assertions</h3>

          <p>In ESBMC, all loops are "unwound", i.e., replaced by several guarded copies of the loop body; the same happens for backward "gotos" and recursive functions. Soundness requires that ESBMC insert a so-called <i>unwinding assertion</i> at the end of the loop. As an example, consider the simple C code fragment illustrated below:</p>

<body>
<pre class='brush: c'>
1 unsigned int x=âˆ—;
2 while ( x>0) xâˆ’âˆ’;
3 assert ( x==0);
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>
</body>

<p> Note that the loop in line 2 runs an unknown number of times, depending on the initial non-deterministic value assigned to x in line 1. The assertion in line 3 holds independent of x's initial value. BMC tools typically fail to verify programs that contain such loops. In particular, BMC tools introduce an unwinding assertion at the end of the loop, as illustrated in line 5 of this C code fragment.

<body>
<pre class='brush: c'>
1 unsigned int x=âˆ—;
2 if(x>0)
3   xâˆ’âˆ’;   // k copies
4   ...
5 assert (!(x>0));
6 assert(x==0);
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>
</body>

<p>This unwinding assertion in line 5 causes the BMC tool to fail if <i>k</i> is too small as follows:</p>

<body>
<pre class='brush: c'>
1 #include &lt;assert.h&gt;
2 unsigned int nondet_uint();
3 int main() {
4   unsigned int x=nondet_uint();
5   while(x>0) x--;
6   assert(x==0);
7   return 0;
8 }
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>
</body>

<pre style="color: silver; background: black;">$esbmc file.c --unwind 3</pre>

<pre style="color: silver; background: black;">
Counterexample:

State 1 file file.c line 4 function main thread 0
----------------------------------------------------
  x = 3170305 (00000000 00110000 01100000 00000001)

State 2 file file.c line 5 function main thread 0
----------------------------------------------------
  x = 3170304 (00000000 00110000 01100000 00000000)

State 3 file file.c line 5 function main thread 0
----------------------------------------------------
  x = 3170303 (00000000 00110000 01011111 11111111)

State 4 file file.c line 5 function main thread 0
----------------------------------------------------
Violated property:
  file file.c line 5 function main
  unwinding assertion loop
</pre>

          <h3 id="modelling-nondeterminism">Modeling with non-determinism</h3>

	  <p>ESBMC extends C with three modeling features:</p>

	  <p> __ESBMC_assert(e): aborts execution when <i>e</i> is false. </p>
<body>
<pre class='brush: c'>
void __ESBMC_assert (e, "some message here");
</pre>
<script src="js/shCore.js"></script>
<script src="js/shBrushCpp.js"></script>
<script>
SyntaxHighlighter.all()
</script>
</body>

          <p> nondet_X(): returns non-deterministic X-value, with X in {bool, char, int, float, double, loff_t, long, pchar, pthread_t, sector_t, short, size_t, u32, uchar, uint, ulong, unsigned, ushort} (no side effects, pointer for void *, etc.). ESBMC assumes that the functions are implemented according to the following template:</p>
<body>
<pre class='brush: c'>
X nondet_X () { X val; return val; }
</pre>
<script src="js/shCore.js"></script>
<script src="js/shBrushCpp.js"></script>
<script>
SyntaxHighlighter.all()
</script>
</body>

          <p> __ESBMC_assume(e): "ignores" execution when <i>e</i> is false, no-op otherwise. </p>
<body>
<pre class='brush: c'>
void __ESBMC_assume(e);
</pre>
<script src="js/shCore.js"></script>
<script src="js/shBrushCpp.js"></script>
<script>
SyntaxHighlighter.all()
</script>
</body>

          <p> __ESBMC_atomic_begin(), __ESBMC_atomic_end(): For modeling an atomic execution of a sequence of statements in a multi-threaded run-time environment, those statements can be placed between two function calls. </p>
<body>
<pre class='brush: c'>
__ESBMC_atomic_begin();
//shared memory
__ESBMC_atomic_end();
</pre>
<script src="js/shCore.js"></script>
<script src="js/shBrushCpp.js"></script>
<script>
SyntaxHighlighter.all()
</script>
</body>

<p>As an illustrative example to show some of the ESBMC features to model non-determinism, consider the following C code:  </p>

<body>
<pre class='brush: c'>
1 int main() {
2   int x=nondet_int(),y=nondet_int(),z=nondet_int();
3   __ESBMC_assume(x > 0 && y > 0 && z > 0);
4   __ESBMC_assume(x < 16384 && y < 16384 && z < 16384);
5   assert(x*x + y*y != z*z);
6   return 0;
7 }
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>
</body>

<p>Here, ESBMC is invoked as follows:</p>

<pre style="color: silver; background: black;">$esbmc file.c</pre>

<p>For this particular C program, ESBMC produces the following counterexample:</p>

<pre style="color: silver; background: black;">
Counterexample:

State 1 file file.c line 2 function main thread 0
----------------------------------------------------
  x = 252 (00000000 00000000 00000000 11111100)

State 2 file file.c line 2 function main thread 0
----------------------------------------------------
  y = 561 (00000000 00000000 00000010 00110001)

State 3 file file.c line 2 function main thread 0
----------------------------------------------------
  z = 615 (00000000 00000000 00000010 01100111)

State 6 file file.c line 5 function main thread 0
----------------------------------------------------
Violated property:
  file file.c line 5 function main
  assertion
  (_Bool)(x * x + y * y != z * z)

VERIFICATION FAILED
</pre>

          <h3 id="falsification">Falsification</h3>

	  <pre style="color: silver; background: black;">$esbmc file.c --falsification</pre>

	  <p>Our falsification approach (<i>--falsification</i>) uses an iterative technique and verifies the program for each unwind bound up to either a maximum default value of <i>50</i> (which can be changed via --max-k-step nr), or indefinitely (until it exhausts the time or memory limits). Intuitively, we aim to find a counterexample with up to <i>k</i> loop unwindings. The algorithm relies on the symbolic execution engine to increasingly unwind the loop after each iteration.</p>

          <p>This approach replaces all unwinding assertions (e.g., assertions to check if a loop was completely unrolled) with unwinding assumptions. Normally, this would lead to unsound behaviour but, since the falsification algorithm cannot provide correctness validation, it will not affect the search for bugs. This approach is focused on bug finding and does not care if a loop was not completely unrolled; it only cares if the current number of unwindings will lead to a property violation.</p>

	  <p>The falsification algorithm also offers the option to change the granularity of the increment; the default value is <i>1</i>, but can be increased in order to meet any expected behaviour via --k-step nr. Note that changing the value of the increment can lead to slower verification time and might not present the shortest counterexample possible for a property violation.</p>

	  <h3 id="incremental-bmc">Incremental BMC</h3>

	  <pre style="color: silver; background: black;">$esbmc file.c --incremental-bmc</pre>

	  <p>Our incremental BMC approach (<i>--incremental-bmc</i>) uses an iterative technique and verifies the program for each unwind bound up to either a maximum default value of <i>50</i>, which can be modified via --max-k-step nr, or indefinitely (until it exhausts the time or memory limits). Intuitively, we aim to either find a counterexample with up to <i>k</i> loop unwinding or to fully unwind all loops so we can provide a correct result. The algorithm relies on the symbolic execution engine to increasingly unwind the loop after each iteration of the algorithm.</p>

          <p>The approach is divided in two steps: one that tries to find property violations and one that checks if all the loops were fully unwound. When searching for property violation, the tool replaces all unwinding assertions (e.g., assertions to check if a loop was completely unrolled) with unwinding
assumptions. Normally, this would lead to unsound behaviour, however, the first step can only find property violations and reporting an unwinding assertion failure is not a real bug. The next step is to check if all loops in the program were fully unrolled. This is done by checking if all the unwinding assertions are unsatisfiable; note that checking any other assertion in the program, for the current <i>k</i>, is not necessary as they were already verified. </p>

          <p>The algorithm also offers the option to change the granularity of the increment; the default value is <i>1</i>, but can be increased in order to meet any expected behaviour via --k-step nr. Note that changing the value of the increment can lead to slower verification time and might not present the shortest counterexample possible for the property violation.</p>

	  <h3 id="k-induction">k-Induction proof rule</h3>

	  <pre style="color: silver; background: black;">$esbmc file.c --k-induction</pre>

	  <p>The original <i>k</i>-induction algorithm (<i>--k-induction</i>) presented by Sheeran et al. [1] was used to prove safety properties in hardware verification. The algorithm was later refined by Alastair et al. [2] and applied to the verification of general C programs. Our algorithm is a combination of both approaches. It can be summarized as follows:</p>

	  \begin{equation}
  \begin{array}{rcrrl}
           & \neg & B(k) & \rightarrow & \text{program contains bug}  \\
    B(k) & \wedge & F(k) & \rightarrow & \text{program is correct}  \\
    B(k) & \wedge & I(k) & \rightarrow & \text{program is correct}
  \end{array}
\end{equation}

           <p> Here <i>B(k)</i> is the base case, <i>F(k)</i> is the forward condition and <i>I(k)</i> is the inductive step; <i>k</i> is the number of loop unwinding used for each step. For the base case we use the plain BMC technique, hence we can only find property violations here. If the base case error check is satisfiable, then the algorithm presents a counterexample of length <i>k</i>. For the forward condition and inductive step, the base case must be checked for satisfiability before the result is presented. This is a soundness requirement of the technique.</p>

	   <p>The forward condition attempts to prove that all loops in the program were fully unrolled; this is achieved by adding <i>unwinding assertions</i> after all loops. The forward condition is further optimized to only check the <i>unwinding assertions</i>, as all program assertions are already proven to be unsatisfiable by the base case, for the current value of <i>k</i>. The inductive step attempts to prove that, if the property is valid for <i>k</i> iterations, then it must be valid for the next iteration; this is achieved by assigning nondeterministic values to all variable written inside a loop body,
assuming <i>k-1</i> invariants and checking if the invariant holds at the <i>k</i>th iteration. </p>

	   <p> The algorithm starts with <i>k = 1</i> and increases it up to a maximum
number of iterations, incrementally analysing the program, until it either finds a bug (i.e., the base case is satisfiable for some <i>k</i>), proves correctness (i.e., the base case is unsatisfiable and either the forward condition or inductive step is unsatisfiable for some <i>k</i>), or exhausts either time or memory constraints.</p>

	   <p>We can also use two additional options together with the k-induction proof rule to produce (inductive) invariants:</p>

	   <ol>
       <li><i>--interval-analysis</i>: enable interval analysis for integer variables and add assumes to the program.</li>
       <li><i>--add-symex-value-sets</i>: enable value set analysis for pointers and add assumes to the program.</li>
       </ol>

	   <p>[1] Mary Sheeran, Satnam Singh, Gunnar StÃ¥lmarck: Checking Safety Properties Using Induction and a SAT-Solver. FMCAD 2000: 108-125</p>
	   <p>[2] Alastair F. Donaldson, Leopold Haller, Daniel Kroening, Philipp RÃ¼mmer: Software Verification Using k-Induction. SAS 2011: 351-368</p>

	   <h3 id="multiple-files">Verification of modules that rely on larger structures</h3>

	   <p>ESBMC can verify code that relies on existing infrastructures and must be compliant with those. Consider the following C program where the verification engineer wants to check whether the assert-statement in line 8 holds.</p>

<head>
<link href="css/shCore.css" rel="stylesheet" type="text/css" />
<link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />
</head>
<body>
<pre class='brush: c'>
1 #include "lib.h"
2 // Running with esbmc  --overflow-check main.c lib.c
3 int main() {
4   int64_t a;
5   int64_t b;
6   int64_t r;
7   if (mul(a, b, &r)) {
8     __ESBMC_assert(r == a * b, "Expected result from multiplication");
9   }
10   return 0;
11 }
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>

  The function <i>mul</i> is implemented in the library "lib.h", which is located under "/lib". Here, ESBMC is invoked as follows:

<pre style="color: silver; background: black;">$esbmc main.c --overflow-check -I lib/ lib/lib.c</pre>

<p>where <i>main.c</i> is the C program to be checked, <i>--overflow-check</i> enables arithmetic over- and underflow check, and <i>-I path</i> sets the include path. For this particular C program, ESBMC produces the following counterexample: </p>

<pre style="color: silver; background: black;">
Counterexample:

State 1 file lib.c line 14 function mul thread 0
----------------------------------------------------
Violated property:
  file lib.c line 14 function mul
  arithmetic overflow on mul
  !overflow("*", a, b)

VERIFICATION FAILED
</pre>

<p>The library header and implementation files located under <i>/lib</i> are:</p>

                     <head>
            <link href="css/shCore.css" rel="stylesheet" type="text/css" />
            <link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />
          </head>
          <body>
          <pre class='brush: c'>
1 #include<stdint.h>
2 _Bool mul(const int64_t a, const int64_t b, int64_t *res);
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>

            <head>
            <link href="css/shCore.css" rel="stylesheet" type="text/css" />
            <link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />
          </head>
          <body>
          <pre class='brush: c'>
 1 #include "lib.h"
 2 _Bool mul(int64_t a, int64_t b, int64_t *res) {
 3   // Trivial cases
 4   if((a == 0) || (b == 0)) {
 5     *res = 0;
 6     return 1;
 7   } else if(a == 1) {
 8     *res = b;
 9     return 1;
10   } else if(b == 1) {
11     *res = a;
12     return 1;
13   }
14   *res = a * b; // there exists an overflow
15   return 1;
16 }
</pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>

	   <h3 id="esbmc-solidity">Verification of Solidity Smart Contracts</h3>

     <p> ESBMC has an early prototype of the frontend to process Solidity source code and hence can verify simple Solidity smart contracts. In order to verify Solidity smart contract, ESBMC should be built with the option <b>'-DENABLE_SOLIDITY_FRONTEND=On'</b>. As an illustrative example, consider the following Solidity code: </p>

<head>
<link href="css/shCore.css" rel="stylesheet" type="text/css" />
<link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />
</head>
<body>
<pre class='brush: c'>
1 // SPDX-License-Identifier: GPL-3.0
2 pragma solidity >=0.4.26;
3
4 contract MyContract {
5
6   function func_array_loop() external pure {
7     uint8[2] memory a;
8
9     a[0] = 100;
10    for (uint8 i = 1; i &lt 3; ++i)
11    {
12      a[i] = 100;
13      assert(a[i-1] == 100);
14    }
15  }
16 }

</pre>
<script src="js/shCore.js"></script>
<script src="js/shBrushCpp.js"></script>
<script>
  SyntaxHighlighter.all()
</script>

  <p> As declared in line 7, <i>a</i> is an static array of the size 2. The loop in line 10 will try to write 10 in <i>a[2]</i> in the third iteration, which is out-of-bound access. This error can be detected by ESBMC using the command lines as follows: </p>

  <pre style="color: silver; background: black;">$esbmc example.solast --function func_array_loop --incremental-bmc</pre>

  <p> where <i>MyContract.solast</i> is the JSON AST of the Solidity source code generated using the command line below:</p>

  <pre style="color: silver; background: black;">$solc --ast-compact-json example.sol > example.solast</pre>

  <p> For this example, ESBMC produces the following counterexample:</p>
<pre style="color: silver; background: black;">
Counterexample:

State 1 file example.sol line 1 function func_array_loop thread 0
----------------------------------------------------
  a[0] = 100 (01100100)

State 2 file example.sol line 1 function func_array_loop thread 0
----------------------------------------------------
  a[1] = 100 (01100100)

State 4 file example.sol line 1 function func_array_loop thread 0
----------------------------------------------------
Violated property:
  file example.sol line 1 function func_array_loop
  array bounds violated: array `a' upper bound
  (signed long int)i &lt 2


VERIFICATION FAILED

Bug found (k = 2)
</pre>

	   <h3 id="esbmc-support">ESBMC Support</h3>

          <p>We are still increasing the robustness of ESBMC and also continuously implementing new features, more optimizations and experiencing new encodings. For any question about ESBMC, please contact us via <code>https://github.com/esbmc/esbmc</code>.</p>

        </section>
      <footer>

        <p><small>Â© 2020 Systems & Software Verification Laboratory</small></p>
      </footer>
    </div>
    <script src="./files/scale.fix.js.download"></script>

</body></html>
