<!DOCTYPE html>
<html lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>

<!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Documentation | ESBMC</title>
<meta name="generator" content="Jekyll v3.7.3">
<meta property="og:title" content="ESBMC: An Industrial-Strength C Model Checker">
<meta property="og:locale" content="en_US">
<meta name="description" content="SMT-based Context-Bounded Model Checker for C Programs.">
<meta property="og:description" content="SMT-based Context-Bounded Model Checker for C Programs.">
<link rel="canonical" href="https://ssvlab.github.io/">
<meta property="og:url" content="https://ssvlab.github.io/">
<meta property="og:site_name" content="ESBMC">
<script type="application/ld+json">
{"name":"ESBMC","description":"SMT-based Context-Bounded Model Checker for C Programs..","@type":"WebSite","url":"https://ssvlab.github.io/","headline":"News","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="./files/style.css">
    <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="https://ssvlab.github.io/esbmc/index.html">ESBMC</a></h1>
        <p>An Efficient SMT-based Bounded Model Checker.</p>
        <p class="view"><a class="hl" href="https://github.com/ssvlab/esbmc"><b>GitHub</b></a></p>
        <p class="view">
          <a href="https://ssvlab.github.io/esbmc/documentation.html"><b>Documentation</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/news.html"><b>News</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/publications.html"><b>Publications</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/sv-comp.html"><b>SV-COMP</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/test-comp.html"><b>Test-Comp</b></a><br>
	  <a href="https://ssvlab.github.io/esbmc/people.html"><b>People</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/applications.html"><b>Applications</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/archive.html"><b>Download Archive</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/contrib.html"><b>Third Party Contributions</b></a><br>
          <a href="https://ssvlab.github.io/esbmc/benchmarks/"><b>Index of /benchmarks</b></a><br>	

        </p>
      </header>
      <section>

      <h2 id="documentation">Documentation</h2>

      <!--  <p>First things first, download the lastest version of ESBMC for Linux OS <a href="https://github.com/esbmc/esbmc/releases/download/v6.0/esbmc-v6.0.0-linux-static-64.tgz"><b>here</b></a>. ESBMC is hosted on <a href="https://github.com/esbmc/esbmc" target="_blank">GitHub</a>.</p> -->

	  <a href="#how-to-install">Installing ESBMC</a>
	  <br>
          <a href="#show-features">ESBMC Features</a>
	  <br>
	  <a href="#how-to-run">Illustrative Examples</a>
	  <br>
          <a href="#unwinding-assertions">Unwinding Assertions</a>
          <br>
          <a href="#modelling-nondeterminism">Modeling with non-determinism</a>
          <br>
          <a href="#verification-strategies">Verification Strategies</a>
          <br>
	  <a href="#esbmc-support">ESBMC Support</a>
	  <br>
          <br>

          <p>A demonstration is available <a href="https://www.youtube.com/watch?v=YcJjXHlN1v8" target="_blank">here</a>.</p>

          <h3 id="how-to-install">Installing ESBMC</h3>

	  <p>As a prerequisite, we recommend to install ESBMC on a GNU/Linux operating system. In order to install ESBMC on your machine, you should download the <a href="https://github.com/esbmc/esbmc/releases/latest/download/ESBMC-Linux.sh">ESBMC-Linux.sh</a> and save it on your disk. After that, you should open the terminal prompt and run the shell script using the following command:</p>

          <pre style="color: silver; background: black;">$chmod +x ESBMC-Linux.sh</pre>
          <pre style="color: silver; background: black;">$./ESBMC-Linux.sh</pre>

          <p>Once the user runs the above shell-script, he/she should read the license before proceeding with the installation. The ESBMC distribution is split into two directories:</p>

          <ul>
              <li><code>bin</code>: contains a static-binary file of ESBMC;</li>
              <li><code>license</code>: contains the ESBMC, Z3 and Boolector licenses.</li>
          </ul>

	  <p>If the user wants to use other SMT solvers (e.g., MathSAT, Yices, CVC4), we recommend checking out ESBMC source code, which is hosted on <a href="https://github.com/esbmc/esbmc" target="_blank">GitHub</a></p>

          <h3 id="show-features">ESBMC Features</h3>

          <p>ESBMC aims to support all of C11, and detects errors in software by simulating a finite prefix of the program execution with all possible inputs. Classes of problems that can be detected include:</p>

          <ul>
              <li>User specified assertion failures;</li>
              <li>Out of bounds array access;</li>
              <li>Illegal pointer dereferences, such as:</li>
              <ul>
                <li>Dereferencing null;</li>
                <li>Performing an out-of-bounds dereference;</li>
                <li>Double-free of malloc'd memory;</li>
                <li>Misaligned memory access;</li>
              </ul>
              <li>Integer overflows;</li>
              <li>NaN (Floating-point);</li>
              <li>Divide by zero;</li>
              <li>Memory leak.</li>
          </ul>

          <p>Concurrent software (using the pthread API) is verified by explicit exploration of interleavings, thus producing one symbolic execution per interleaving. By default, only normal errors will be checked for; one can also specify options to check concurrent programs for:</p>

          <ul>
            <li>Deadlock (only on pthread mutexes and conditional variables);</li>
            <li>Data races (<i>i.e.</i>, competing writes);</li>
          </ul>

          <p>By default ESBMC performs a ''lazy'' depth first search of interleavings, but can also encode (explicitly) all interleavings into a single SMT formula. Currently, a number of SMT solvers are supported:</p>

          <ul>
            <li>Z3 4.8+;</li>
            <li>Boolector 3.2+;</li>
            <li>MathSAT 5.6+;</li>
            <li>CVC4;</li>
            <li>Yices 2.6+;</li>
          </ul>

          <p>In addition, ESBMC can be configured to use the SMTLIB interactive text format with a pipe, to communicate with an arbitrary solver process, although not-insignificant overheads are involved. A limited subset of C++98 is supported too -- a library modeling the STL is also available.</p>

          <p>To check all available options of the ESBMC tool, type:</p>

          <pre style="color: silver; background: black;">$esbmc --help</pre>

	  	  <h3 id="how-to-run">Illustrative Examples</h3>

          <p>As an illustrative example to show some of the ESBMC features concerning floating-point numbers, consider the following C code:  </p>

	  <head>
            <link href="css/shCore.css" rel="stylesheet" type="text/css" />
            <link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />
          </head>

          <body>
          <pre class='brush: c'>
#include &lt;math.h&gt;
int main() {
  unsigned int N = nondet_uint();
  double x = nondet_double();
  if(x <= 0 || isnan(x))
    return 0;
  unsigned int i = 0;
  while(i < N) {
    x = (2*x);
    assert(x>0);
    ++i;
  }
  assert(x>0);
  return 0;
}
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>
</body>

          <p>Here, ESBMC is invoked as follows: </p>

          <pre style="color: silver; background: black;">$esbmc file.c --floatbv --k-induction</pre>

	  <p> where <i>file.c</i> is the C program to be checked, <i>--floatbv</i> indicates that ESBMC will use floating-point arithmetic to represent the program's <i>float</i> and <i>double</i> variables, and <i>--k-induction</i> selects the <i>k</i>-induction proof rule. The user can select the SMT solver, property, and verification strategy. For this particular C program, ESBMC provides the following output as the verification result:</p>

<pre style="color: silver; background: black;">
*** Checking inductive step
Starting Bounded Model Checking
Unwinding loop 2 iteration 1 file ex5.c line 8 function main
Not unwinding loop 2 iteration 2 file ex5.c line 8 function main
Symex completed in: 0.001s (40 assignments)
Slicing time: 0.000s (removed 16 assignments)
Generated 2 VCC(s), 2 remaining after simplification (24 assignments)
No solver specified; defaulting to Boolector
Encoding remaining VCC(s) using bit-vector/floating-point arithmetic
Encoding to solver time: 0.005s
Solving with solver Boolector 3.2.0
Encoding to solver time: 0.005s
Runtime decision procedure: 0.427s
BMC program time: 0.435s

VERIFICATION SUCCESSFUL

Solution found by the inductive step (k = 2)
</pre>

<p>As antoher illustrative example to show some of the ESBMC features concerning pointer safety, consider the following C code:  </p>

	  <head>
            <link href="css/shCore.css" rel="stylesheet" type="text/css" />
            <link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />
          </head>

          <body>
          <pre class='brush: c'>
#include &lt;stdlib.h&gt;
int *a, *b;
int n;
#define BLOCK_SIZE 128
void foo () {
  int i;
  for (i = 0; i < n; i++)
    a[i] = -1;
  for (i = 0; i < BLOCK_SIZE - 1; i++)
    b[i] = -1;
}
int main () {
  n = BLOCK_SIZE;
  a = malloc (n * sizeof(*a));
  b = malloc (n * sizeof(*b));
  *b++ = 0;
  foo ();
  if (b[-1])
  { free(a); free(b); }
  else
  { free(a); free(b); }
  return 0;
}
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>
</body>

          <p>Here, ESBMC is invoked as follows: </p>

          <pre style="color: silver; background: black;">$esbmc file.c --memory-leak-check</pre>

	  <p> where <i>file.c</i> is the C program to be checked and <i>--memory-leak-check</i> indicates that ESBMC will check for memory leaks. For this particular C program, ESBMC produces the following counterexample:</p>

<pre style="color: silver; background: black;">
Counterexample:

State 1 file ex2.c line 14 function main thread 0
----------------------------------------------------
  a = (signed int *)(&dynamic_1_array[0])

State 2 file ex2.c line 15 function main thread 0
----------------------------------------------------
  b = (signed int *)0

State 3 file ex2.c line 16 function main thread 0
----------------------------------------------------
  b = 0 + 1

State 6 file ex2.c line 16 function main thread 0
----------------------------------------------------
Violated property:
  file ex2.c line 16 function main
  dereference failure: NULL pointer
</pre>

          <p>In the counterexample shown above, State 1 indicates that memory has been allocated, which is identified by 'dynamic_1_array'. State 2 indicates that the call to the malloc function did not succeed, and thus returned NULL, i.e., the memory was not allocated. State 3 represents an assignment to pointer b. Lastly, State 6 reports a failure to dereference pointer b.</p>


          <h3 id="unwinding-assertions">Unwinding Assertions</h3>

          <p>In ESBMC, all loops are "unwound", i.e., replaced by several guarded copies of the loop body; the same happens for backward "gotos" and recursive functions. Soundness requires that ESBMC insert a so-called <i>unwinding assertion</i> at the end of the loop. As an example, consider the simple C code fragment illustrated below:</p>
	  
<body>
<pre class='brush: c'>
1 unsigned int x=∗;
2 while ( x>0) x−−;
3 assert ( x==0);
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>
</body>
	  
<p> Note that the loop in line 2 runs an unknown number of times, depending on the initial non-deterministic value assigned to x in line 1. The assertion in line 3 holds independent of x's initial value. BMC tools typically fail to verify programs that contain such loops. In particular, BMC tools introduce an unwinding assertion at the end of the loop, as illustrated in line 5 of this C code fragment. 

<body>  
<pre class='brush: c'>
1 unsigned int x=∗;
2 if(x>0)
3   x−−;   // k copies
4   ...
5 assert (!(x>0));
6 assert(x==0);
  </pre>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCpp.js"></script>
  <script>
    SyntaxHighlighter.all()
  </script>
</body>

<p>This unwinding assertion in line 5 causes the BMC tool to fail if <i>k</i> is too small.</p>

          <h3 id="modelling-nondeterminism">Modeling with non-determinism</h3>

	  <p>ESBMC extends C with three modeling features:</p>
        
	  <p> assert(e): aborts execution when <i>e</i> is false. </p>
<body>
<pre class='brush: c'>
void __ESBMC_assert (e, "some message here");
</pre>
<script src="js/shCore.js"></script>
<script src="js/shBrushCpp.js"></script>
<script>
SyntaxHighlighter.all()
</script>
</body>

          <p> nondet_int(): returns non-deterministic int-value. </p>
<body>
<pre class='brush: c'>
int nondet_int () { int x; return x; }
</pre>
<script src="js/shCore.js"></script>
<script src="js/shBrushCpp.js"></script>
<script>
SyntaxHighlighter.all()
</script>
</body>

          <p> nondet_char(): returns non-deterministic char-value. </p>
<body>
<pre class='brush: c'>
char nondet_int () { char x; return x; }
</pre>
<script src="js/shCore.js"></script>
<script src="js/shBrushCpp.js"></script>
<script>
SyntaxHighlighter.all()
</script>
</body>

          <p> assume(e): "ignores" execution when <i>e</i> is false, no-op otherwise. </p>
<body>
<pre class='brush: c'>
void __ESBMC_assume(e);
</pre>
<script src="js/shCore.js"></script>
<script src="js/shBrushCpp.js"></script>
<script>
SyntaxHighlighter.all()
</script>
</body>

          <h3 id="verification-strategies">Verification Strategies</h3>

          <p><b>Falsification</b><p>

	  <p>Our falsification approach (<i>--falsification</i>) uses an iterative technique and verifies the program for each unwind bound up to either a maximum default value of <i>50</i> (which can be changed via --max-k-step nr), or indefinitely (until it exhausts the time or memory limits). Intuitively, we aim to find a counterexample with up to <i>k</i> loop unwindings. The algorithm relies on the symbolic execution engine to increasingly unwind the loop after each iteration.</p>

          <p>This approach replaces all unwinding assertions (e.g., assertions to check if a loop was completely unrolled) with unwinding assumptions. Normally, this would lead to unsound behaviour but, since the falsification algorithm cannot provide correctness validation, it will not affect the search for bugs. This approach is focused on bug finding and does not care if a loop was not completely unrolled; it only cares if the current number of unwindings will lead to a property violation.</p>

	  <p>The falsification algorithm also offers the option to change the granularity of the increment; the default value is <i>1</i>, but can be increased in order to meet any expected behaviour via --k-step nr. Note that changing the value of the increment can lead to slower verification time and might not present the shortest counterexample possible for a property violation.</p> 
	 
	  <p><b>Incremental</b></p>

	  <p>Our incremental BMC approach (<i>--incremental-bmc</i>) uses an iterative technique and verifies the program for each unwind bound up to either a maximum default value of <i>50</i>, which can be modified via --max-k-step nr, or indefinitely (until it exhausts the time or memory limits). Intuitively, we aim to either find a counterexample with up to <i>k</i> loop unwinding or to fully unwind all loops so we can provide a correct result. The algorithm relies on the symbolic execution engine to increasingly unwind the loop after each iteration of the algorithm.</p>

          <p>The approach is divided in two steps: one that tries to find property violations and one that checks if all the loops were fully unwound. When searching for property violation, the tool replaces all unwinding assertions (e.g., assertions to check if a loop was completely unrolled) with unwinding
assumptions. Normally, this would lead to unsound behaviour, however, the first step can only find property violations and reporting an unwinding assertion failure is not a real bug. The next step is to check if all loops in the program were fully unrolled. This is done by checking if all the unwinding assertions are unsatisfiable; note that checking any other assertion in the program, for the current <i>k</i>, is not necessary as they were already verified. </p>

          <p>The algorithm also offers the option to change the granularity of the increment; the default value is <i>1</i>, but can be increased in order to meet any expected behaviour via --k-step nr. Note that changing the value of the increment can lead to slower verification time and might not present the shortest counterexample possible for the property violation.</p>

	  <p><b><i>k</i>-Induction</b></p>

	  <p>The original <i>k</i>-induction algorithm (<i>--k-induction</i>) presented by Sheeran et al. [1] was used to prove safety properties in hardware verification. The algorithm was later refined by Alastair et al. [2] and applied to the verification of general C programs. Our algorithm is a combination of both approaches. It can be summarized as follows:</p>

	  \begin{equation}
  \begin{array}{rcrrl}
           & \neg & B(k) & \rightarrow & \text{program contains bug}  \\
    B(k) & \wedge & F(k) & \rightarrow & \text{program is correct}  \\
    B(k) & \wedge & I(k) & \rightarrow & \text{program is correct}
  \end{array}
\end{equation}

           <p> Here <i>B(k)</i> is the base case, <i>F(k)</i> is the forward condition and <i>I(k)</i> is the inductive step; <i>k</i> is the number of loop unwinding used for each step. For the base case we use the plain BMC technique, hence we can only find property violations here. If the base case error check is satisfiable, then the algorithm presents a counterexample of length <i>k</i>. For the forward condition and inductive step, the base case must be checked for satisfiability before the result is presented. This is a soundness requirement of the technique.</p>

	   <p>The forward condition attempts to prove that all loops in the program were fully unrolled; this is achieved by adding <i>unwinding assertions</i> after all loops. The forward condition is further optimized to only check the <i>unwinding assertions</i>, as all program assertions are already proven to be unsatisfiable by the base case, for the current value of <i>k</i>. The inductive step attempts to prove that, if the property is valid for <i>k</i> iterations, then it must be valid for the next iteration; this is achieved by assigning nondeterministic values to all variable written inside a loop body,
assuming <i>k-1</i> invariants and checking if the invariant holds at the <i>k</i>th iteration. </p>

	   <p> The algorithm starts with <i>k = 1</i> and increases it up to a maximum
number of iterations, incrementally analysing the program, until it either finds a bug (i.e., the base case is satisfiable for some <i>k</i>), proves correctness (i.e., the base case is unsatisfiable and either the forward condition or inductive step is unsatisfiable for some <i>k</i>), or exhausts either time or memory constraints.</p>
	  
	   <p>[1] Mary Sheeran, Satnam Singh, Gunnar Stålmarck: Checking Safety Properties Using Induction and a SAT-Solver. FMCAD 2000: 108-125</p>
	   <p>[2] Alastair F. Donaldson, Leopold Haller, Daniel Kroening, Philipp Rümmer: Software Verification Using k-Induction. SAS 2011: 351-368</p>
	   <h3 id="esbmc-support">ESBMC Support</h3>
	  
          <p>We are still increasing the robustness of ESBMC and also continuously implementing new features, more optimizations and experiencing new encodings. For any question about ESBMC, please contact us via <code>https://github.com/esbmc/esbmc</code>.</p>

        </section>
      <footer>

        <p><small>© 2020 Systems & Software Verification Laboratory</small></p>
      </footer>
    </div>
    <script src="./files/scale.fix.js.download"></script>



</body></html>
